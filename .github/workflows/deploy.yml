name: Deploy InterV Application

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'README.md'
      - 'docs/**'

env:
  AWS_REGION: ap-northeast-2
  APPLICATION_NAME: interv

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest
    if: contains(github.event.head_commit.message, '[deploy-infra]') || contains(github.event.head_commit.modified, 'infrastructure/')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: ~1.6.0
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Initialize Terraform
      run: |
        cd infrastructure/
        echo "🏗️ Initializing Terraform..."
        terraform init
    
    - name: Smart Resource Discovery and Import
      env:
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_key_pair_name: ${{ secrets.EC2_KEY_PAIR_NAME }}
        TF_VAR_aws_region: ${{ env.AWS_REGION }}
        TF_VAR_app_name: ${{ env.APPLICATION_NAME }}
        TF_VAR_domain_name: "interv.swote.dev"
      run: |
        cd infrastructure/
        
        echo "🔍 Discovering existing AWS resources..."
        
        # 리소스 검색 및 자동 import 함수
        auto_import_resource() {
            local resource_type="$1"
            local resource_name="$2"
            local aws_resource_id="$3"
            local check_command="$4"
            
            echo "  🔍 Checking $resource_type: $resource_name"
            
            if eval "$check_command" >/dev/null 2>&1; then
                echo "    ✅ Found existing resource: $aws_resource_id"
                if terraform import "$resource_name" "$aws_resource_id" 2>/dev/null; then
                    echo "    📥 Successfully imported: $resource_name"
                else
                    echo "    ⚠️ Import failed or already imported: $resource_name"
                fi
            else
                echo "    ❌ Resource not found: $resource_type"
            fi
        }
        
        echo ""
        echo "📥 Starting automatic resource import..."
        echo ""
        
        # 1. VPC 관련 리소스 (있다면)
        echo "🌐 VPC Resources:"
        VPC_ID=$(aws ec2 describe-vpcs --filters "Name=tag:Name,Values=interv-vpc" --query 'Vpcs[0].VpcId' --output text 2>/dev/null || echo "None")
        if [ "$VPC_ID" != "None" ] && [ "$VPC_ID" != "null" ]; then
            auto_import_resource "VPC" "aws_vpc.main" "$VPC_ID" "aws ec2 describe-vpcs --vpc-ids $VPC_ID"
        fi
        
        # 2. S3 Bucket
        echo "🪣 S3 Resources:"
        S3_BUCKET=$(aws s3api list-buckets --query "Buckets[?starts_with(Name, 'interv-storage-')].Name" --output text 2>/dev/null || echo "None")
        if [ "$S3_BUCKET" != "None" ] && [ "$S3_BUCKET" != "null" ]; then
            auto_import_resource "S3 Bucket" "aws_s3_bucket.app_storage" "$S3_BUCKET" "aws s3api head-bucket --bucket $S3_BUCKET"
            auto_import_resource "S3 Versioning" "aws_s3_bucket_versioning.app_storage" "$S3_BUCKET" "aws s3api get-bucket-versioning --bucket $S3_BUCKET"
        fi
        
        # 3. IAM Resources
        echo "👤 IAM Resources:"
        auto_import_resource "IAM Role" "aws_iam_role.ec2_role" "interv-ec2-role" "aws iam get-role --role-name interv-ec2-role"
        auto_import_resource "IAM Role Policy" "aws_iam_role_policy.ec2_policy" "interv-ec2-role:interv-ec2-policy" "aws iam get-role-policy --role-name interv-ec2-role --policy-name interv-ec2-policy"
        auto_import_resource "IAM Instance Profile" "aws_iam_instance_profile.ec2_profile" "interv-ec2-profile" "aws iam get-instance-profile --instance-profile-name interv-ec2-profile"
        
        # 4. RDS Resources
        echo "🗄️ RDS Resources:"
        auto_import_resource "DB Subnet Group" "aws_db_subnet_group.main" "interv-db-subnet-group" "aws rds describe-db-subnet-groups --db-subnet-group-name interv-db-subnet-group"
        auto_import_resource "RDS Instance" "aws_db_instance.main" "interv-db" "aws rds describe-db-instances --db-instance-identifier interv-db"
        
        # 5. Load Balancer Resources
        echo "⚖️ Load Balancer Resources:"
        ALB_ARN=$(aws elbv2 describe-load-balancers --names interv-alb --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || echo "None")
        if [ "$ALB_ARN" != "None" ] && [ "$ALB_ARN" != "null" ]; then
            auto_import_resource "Application Load Balancer" "aws_lb.main" "$ALB_ARN" "aws elbv2 describe-load-balancers --load-balancer-arns $ALB_ARN"
            
            # ALB Listener
            LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn "$ALB_ARN" --query 'Listeners[0].ListenerArn' --output text 2>/dev/null || echo "None")
            if [ "$LISTENER_ARN" != "None" ] && [ "$LISTENER_ARN" != "null" ]; then
                auto_import_resource "ALB Listener" "aws_lb_listener.app" "$LISTENER_ARN" "aws elbv2 describe-listeners --listener-arns $LISTENER_ARN"
            fi
        fi
        
        TG_ARN=$(aws elbv2 describe-target-groups --names interv-tg --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "None")
        if [ "$TG_ARN" != "None" ] && [ "$TG_ARN" != "null" ]; then
            auto_import_resource "Target Group" "aws_lb_target_group.app" "$TG_ARN" "aws elbv2 describe-target-groups --target-group-arns $TG_ARN"
        fi
        
        # 6. Auto Scaling Resources
        echo "🔄 Auto Scaling Resources:"
        auto_import_resource "Auto Scaling Group" "aws_autoscaling_group.app" "interv-asg" "aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names interv-asg"
        
        LT_ID=$(aws ec2 describe-launch-templates --launch-template-names interv-lt --query 'LaunchTemplates[0].LaunchTemplateId' --output text 2>/dev/null || echo "None")
        if [ "$LT_ID" != "None" ] && [ "$LT_ID" != "null" ]; then
            auto_import_resource "Launch Template" "aws_launch_template.app" "$LT_ID" "aws ec2 describe-launch-templates --launch-template-ids $LT_ID"
        fi
        
        # 7. Elastic IP Resources
        echo "🌐 Elastic IP Resources:"
        EIP_IDS=$(aws ec2 describe-addresses --query 'Addresses[].AllocationId' --output text 2>/dev/null)
        if [ -n "$EIP_IDS" ]; then
            EIP_ARRAY=($EIP_IDS)
            echo "    Found ${#EIP_ARRAY[@]} EIPs"
            
            # NAT Gateway EIPs
            for i in 0 1; do
                if [ $i -lt ${#EIP_ARRAY[@]} ]; then
                    EIP_ID=${EIP_ARRAY[$i]}
                    auto_import_resource "EIP[$i]" "aws_eip.nat[$i]" "$EIP_ID" "aws ec2 describe-addresses --allocation-ids $EIP_ID"
                fi
            done
        fi
        
        # 8. Certificate Resources
        echo "🔐 Certificate Resources:"
        CERT_ARN=$(aws acm list-certificates --query "CertificateSummaryList[?DomainName=='interv.swote.dev'].CertificateArn" --output text 2>/dev/null || echo "None")
        if [ "$CERT_ARN" != "None" ] && [ "$CERT_ARN" != "null" ]; then
            auto_import_resource "ACM Certificate" "aws_acm_certificate.main" "$CERT_ARN" "aws acm describe-certificate --certificate-arn $CERT_ARN"
        fi
        
        # 9. Security Groups
        echo "🔒 Security Group Resources:"
        ALB_SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=interv-alb-sg-*" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "None")
        if [ "$ALB_SG_ID" != "None" ] && [ "$ALB_SG_ID" != "null" ]; then
            auto_import_resource "ALB Security Group" "aws_security_group.alb" "$ALB_SG_ID" "aws ec2 describe-security-groups --group-ids $ALB_SG_ID"
        fi
        
        EC2_SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=interv-ec2-sg-*" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "None")
        if [ "$EC2_SG_ID" != "None" ] && [ "$EC2_SG_ID" != "null" ]; then
            auto_import_resource "EC2 Security Group" "aws_security_group.ec2" "$EC2_SG_ID" "aws ec2 describe-security-groups --group-ids $EC2_SG_ID"
        fi
        
        RDS_SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=interv-rds-sg-*" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "None")
        if [ "$RDS_SG_ID" != "None" ] && [ "$RDS_SG_ID" != "null" ]; then
            auto_import_resource "RDS Security Group" "aws_security_group.rds" "$RDS_SG_ID" "aws ec2 describe-security-groups --group-ids $RDS_SG_ID"
        fi
        
        echo ""
        echo "✅ Resource discovery and import completed!"
        echo ""
    
    - name: Terraform Plan and Apply
      env:
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_key_pair_name: ${{ secrets.EC2_KEY_PAIR_NAME }}
        TF_VAR_aws_region: ${{ env.AWS_REGION }}
        TF_VAR_app_name: ${{ env.APPLICATION_NAME }}
        TF_VAR_domain_name: "interv.swote.dev"
      run: |
        cd infrastructure/
        
        echo "📋 Running terraform plan after import..."
        terraform plan -out=tfplan
        
        echo "🚀 Applying infrastructure changes..."
        terraform apply tfplan
        
        echo "📊 Saving Terraform outputs..."
        terraform output -json > terraform-outputs.json
        
        # S3 버킷 이름을 GitHub Environment에 저장
        S3_BUCKET=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
        if [ -n "$S3_BUCKET" ]; then
            echo "S3_BUCKET_NAME=$S3_BUCKET" >> $GITHUB_ENV
            echo "🪣 S3 Bucket: $S3_BUCKET"
        fi
    
    outputs:
      s3_bucket_name: ${{ env.S3_BUCKET_NAME }}

  build-and-deploy:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure]
    if: always() && !failure()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'corretto'
    
    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2
    
    - name: Build application
      run: |
        echo "📦 Building Spring Boot application..."
        
        # 프로젝트 구조에 따라 빌드 디렉토리 찾기
        if [ -d "inter-v" ]; then
          cd inter-v
          echo "Building in inter-v directory"
        elif [ -d "BE/inter-v" ]; then
          cd BE/inter-v
          echo "Building in BE/inter-v directory"
        else
          echo "❌ Application directory not found!"
          exit 1
        fi
        
        mvn clean package -DskipTests
        
        # 빌드 결과 확인
        JAR_FILE=$(find target -name "*.jar" | head -1)
        if [ -n "$JAR_FILE" ]; then
          echo "✅ Build successful: $JAR_FILE"
        else
          echo "❌ Build failed: No JAR file found"
          exit 1
        fi
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get S3 bucket name
      id: get-bucket
      run: |
        # Terraform state에서 S3 버킷 이름 가져오기
        cd infrastructure/
        terraform init
        S3_BUCKET=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
        
        if [ -z "$S3_BUCKET" ]; then
          echo "❌ S3 bucket name not found!"
          exit 1
        fi
        
        echo "S3_BUCKET=$S3_BUCKET" >> $GITHUB_OUTPUT
        echo "🪣 Using S3 bucket: $S3_BUCKET"
    
    - name: Upload JAR to S3
      env:
        S3_BUCKET: ${{ steps.get-bucket.outputs.S3_BUCKET }}
      run: |
        echo "📤 Uploading application to S3..."
        
        # JAR 파일 찾기
        if [ -d "inter-v" ]; then
          JAR_PATH="inter-v/target"
        elif [ -d "BE/inter-v" ]; then
          JAR_PATH="BE/inter-v/target"
        else
          JAR_PATH="target"
        fi
        
        JAR_FILE=$(find $JAR_PATH -name "*.jar" | head -1)
        
        if [ -n "$JAR_FILE" ]; then
          # 타임스탬프와 함께 업로드
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          
          # 백업용 업로드
          aws s3 cp "$JAR_FILE" "s3://$S3_BUCKET/releases/$TIMESTAMP/$APPLICATION_NAME.jar"
          
          # 최신 버전 업로드
          aws s3 cp "$JAR_FILE" "s3://$S3_BUCKET/releases/latest/$APPLICATION_NAME.jar"
          
          # 배포 정보 업로드
          echo "{\"timestamp\":\"$TIMESTAMP\",\"commit\":\"$GITHUB_SHA\",\"branch\":\"$GITHUB_REF_NAME\",\"actor\":\"$GITHUB_ACTOR\"}" > deployment-info.json
          aws s3 cp deployment-info.json "s3://$S3_BUCKET/releases/latest/deployment-info.json"
          
          echo "✅ JAR uploaded successfully: $JAR_FILE"
          echo "📦 Backup: s3://$S3_BUCKET/releases/$TIMESTAMP/"
          echo "🔄 Latest: s3://$S3_BUCKET/releases/latest/"
        else
          echo "❌ JAR file not found in $JAR_PATH"
          exit 1
        fi
    
    - name: Trigger Auto Scaling Group refresh
      run: |
        echo "🔄 Triggering Auto Scaling Group refresh..."
        
        ASG_NAME="${APPLICATION_NAME}-asg"
        
        # ASG 존재 확인
        if ! aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names $ASG_NAME >/dev/null 2>&1; then
          echo "⚠️ Auto Scaling Group not found, skipping refresh..."
          exit 0
        fi
        
        # 현재 인스턴스 상태 확인
        aws autoscaling describe-auto-scaling-groups \
          --auto-scaling-group-names $ASG_NAME \
          --query 'AutoScalingGroups[0].{Desired:DesiredCapacity,Running:Instances[?LifecycleState==`InService`]|length(@)}'
        
        # 인스턴스 새로고침 시작
        REFRESH_ID=$(aws autoscaling start-instance-refresh \
          --auto-scaling-group-name $ASG_NAME \
          --preferences MinHealthyPercentage=50,InstanceWarmup=300,CheckpointPercentages=50 \
          --query 'InstanceRefreshId' --output text)
        
        echo "🔄 Instance refresh started: $REFRESH_ID"
        echo "⏳ Waiting for instance refresh to complete..."
        
        # 완료 대기 (타임아웃 20분)
        timeout 1200 aws autoscaling wait instance-refresh-successful \
          --auto-scaling-group-name $ASG_NAME \
          --instance-refresh-ids $REFRESH_ID || {
          echo "⚠️ Instance refresh timeout, but continuing..."
        }
        
        echo "✅ Instance refresh completed!"
    
    - name: Health check and verification
      run: |
        echo "🔍 Performing post-deployment health checks..."
        
        # 애플리케이션 시작 대기
        echo "⏳ Waiting for application startup (60 seconds)..."
        sleep 60
        
        # Health check
        HEALTH_URL="https://interv.swote.dev/actuator/health"
        MAX_ATTEMPTS=10
        
        for i in $(seq 1 $MAX_ATTEMPTS); do
          echo "🏥 Health check attempt $i/$MAX_ATTEMPTS..."
          
          if curl -f -s --max-time 10 "$HEALTH_URL" > /dev/null; then
            echo "✅ Application is healthy!"
            
            # 상세 상태 확인
            echo "📊 Application status:"
            curl -s --max-time 10 "$HEALTH_URL" | jq . || curl -s --max-time 10 "$HEALTH_URL"
            
            break
          else
            if [ $i -eq $MAX_ATTEMPTS ]; then
              echo "❌ Health check failed after $MAX_ATTEMPTS attempts"
              echo "🔍 Checking ALB target health..."
              
              # ALB 타겟 그룹 상태 확인
              TARGET_GROUP_ARN=$(aws elbv2 describe-target-groups \
                --names "${APPLICATION_NAME}-tg" \
                --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "None")
              
              if [ "$TARGET_GROUP_ARN" != "None" ]; then
                aws elbv2 describe-target-health \
                  --target-group-arn $TARGET_GROUP_ARN
              fi
              
              exit 1
            fi
            
            echo "⏳ Waiting 30 seconds before retry..."
            sleep 30
          fi
        done
        
        echo ""
        echo "🎉 Deployment completed successfully!"
        echo "🌐 Application URL: https://interv.swote.dev"
        echo "🏥 Health Check: https://interv.swote.dev/actuator/health"
        echo "📊 Monitoring: AWS CloudWatch Console"